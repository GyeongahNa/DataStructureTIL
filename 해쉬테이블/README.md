## 해쉬/테이블

### 테이블
key, value 가 한 쌍으로 저장된 표 형식의 자료구조<br/>
key를 바탕으로 O(1)의 시간복잡도에 삽입, 탐색, 삭제 가능
<br></br>

**ADT**

```
  void TBLInit(Table* pt, HashFunc f);
  void TBLInsert(Table* pt, Key key, Value val);
  void TBLSearch(Table* pt, Key key);
  void TBLDelete(Table* pt, Key key);
```

### Hash Function

key를 바탕으로 value를 바로 탐색하려면, key를 배열의 인덱스로 사용해야 함. 그런데, key가 숫자가 아닌 경우 key를 인덱스로 사용하는 것은 불가능 할뿐더러, key가 숫자라 하더라도 전체 숫자의 범위가 매우 넓어 필요 이상의 메모리를 쓰게 됨</br></br>
해당 문제를 해결하기 위해, key를 더 작은 범위의 숫자로 변경하는 해쉬 함수를 사용. 예를 들어, `f(k) = k%100` 이고, 학번(key)과 이름(value)으로 이루어진 데이터를 저장한다고 할 때, key가 `20171003`인 데이터는 `f(k) = 3`번 인덱스에 저장
<br></br>

### 충돌(Collision)

해쉬 함수는 넓은 범위의 key 값을 좁은 범위의 인덱스로 줄여준다는 장점이 있으나, 다른 key 값에 대하여 동일한 인덱스를 도출 할 수 있음
<br></br>

**충돌의 해결 방법**

* **열린 어드레싱 방법(Open addressing method)**
    * 충돌이 일어나면 다른 자리에 저장하는 방식
    * **선형 조사법**
        * f(k)에서 충돌이 일어날 경우, f(k)+1, f(k)+2, f(k)+3, ... 순으로 빈 자리를 탐색하여 저장
        * 특정 구역에 클러스터가 형성되고, 충돌의 빈도가 높아짐
    * **이차 조사법**
        * 선형 조사법에서 개선된 방법으로, 충돌지점에서 더 먼 위치에서 빈 자리를 탐색
        * f(k)에서 충돌이 일어날 경우, f(k)+1^2, f(k)+2^2, f(k)+3^3, ... 순으로 빈 자리를 탐색하여 저장
    * **이중 해쉬**
        * 선형 조사법, 이차 조사법의 경우 같은 해쉬 함수 결과를 갖는 키는 계속해서 동일한 위치를 탐색하게 되는 문제점이 있음
        * 해쉬 함수를 이중으로 구성하여 1차 해쉬 함수는 첫번째로 탐색하는 인덱스 위치를, 2차 해쉬 함수는 충돌이 일어난 경우 앞으로 이동하는 거리를 판단
        * 해쉬 함수의 일반 모형
            * h1(k) = k%N(N은 배열의 크기)
            * h2(k) = 1+(k%C)(C는 N보다 작은 소수)
            * h1(k)에서 충돌이 일어나면 h2(k)만큼씩 이동하여 다음 빈자리 탐색

* **닫힌 어드레싱 방법(Closed addressing method)**
    * **체이닝**
        * 같은 해쉬 함수 값을 가지는 slot(key, value)들을 연결리스트로 연결 방식
        * [**체이닝을 이용한 해시테이블 구현**](https://github.com/GyeongahNa/DataStructureTIL/blob/main/%ED%95%B4%EC%89%AC%ED%85%8C%EC%9D%B4%EB%B8%94/HashTable.c)
